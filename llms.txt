# EdgeBinder Project - LLM Context

## Project Overview

EdgeBinder is a lightweight, storage-agnostic relationship management library for PHP 8.3+ that follows Domain-Driven Design principles. It provides a clean abstraction layer for managing entity relationships with rich metadata support across various storage backends through pluggable adapters.

### Core Value Proposition
"Bind entities with rich, metadata-driven relationships using storage-agnostic flexibility"

### Key Features
- **Storage Agnostic**: Use any storage backend through pluggable adapters
- **Rich Metadata**: Store complex relationship data with full metadata support
- **Type Safe**: Full PHP 8.3+ type safety with comprehensive PHPStan level 8 analysis
- **Domain-Driven Design**: Clean abstraction that doesn't pollute domain entities
- **Framework Agnostic**: Works with Laminas, Symfony, Laravel, Slim, and any PSR-11 framework
- **Extensible**: Plugin architecture for third-party adapters

## Repository Structure

### Core Repository (edgebinder/edgebinder)
- **Main EdgeBinder class**: `src/EdgeBinder.php` - Primary API for relationship management
- **Contracts**: `src/Contracts/` - Core interfaces (EdgeBinderInterface, PersistenceAdapterInterface, etc.)
- **Binding Entity**: `src/Binding.php` - Immutable binding representation
- **Query Builder**: `src/Query/BindingQueryBuilder.php` - Fluent query interface
- **Registry System**: `src/Registry/` - Framework-agnostic adapter extensibility
- **InMemory Adapter**: `src/Persistence/InMemory/` - Built-in adapter for testing and development
- **Exceptions**: `src/Exception/` - Comprehensive error handling

### Built-in Adapters
- **InMemoryAdapter**: Built-in in-memory adapter for testing and development (`src/Persistence/InMemory/`)

### **⚠️ CRITICAL: Adapter Testing Requirement**
**ALL adapters MUST extend `AbstractAdapterTestSuite`** to ensure compliance:
- 57+ comprehensive integration tests required
- Tests all query patterns, metadata handling, and edge cases
- Proven to catch production bugs (found 5+ critical issues)
- See `docs/ADAPTER_TESTING_STANDARD.md` for complete guide

### Adapter Repositories
- **edgebinder/weaviate-adapter**: Vector database adapter for Weaviate
- **Future adapters**: Neo4j, Redis, MongoDB, JanusGraph, etc.

### Framework Components
- **edgebinder/laminas-component**: Laminas/Mezzio integration component
- **Future components**: Symfony bundle, Laravel package, etc.

## Core Architecture

### 🚀 v0.6.0 Revolutionary Criteria Transformer Pattern

EdgeBinder v0.6.0 introduces a **revolutionary architecture** that makes adapters dramatically simpler and more maintainable:

#### Before v0.6.0: Heavy Adapters (50+ lines of conversion logic)
```php
public function executeQuery(QueryBuilderInterface $query): array {
    $criteria = $query->getCriteria();
    $filters = [];
    if ($criteria['from']) {
        // 20+ lines of complex conversion logic...
    }
    // ... many more lines of manual conversion
    return $this->executeNativeQuery($convertedQuery);
}
```

#### v0.6.0+: Light Adapters (Just 3 lines!)
```php
public function executeQuery(QueryCriteria $criteria): QueryResultInterface {
    $query = $criteria->transform($this->transformer);  // 1 line transformation!
    return new QueryResult($this->executeNativeQuery($query));
}
```

### Key v0.6.0 Components

#### CriteriaTransformerInterface (src/Contracts/CriteriaTransformerInterface.php)
**NEW in v0.6.0** - Contract for adapter-specific query transformations:
```php
interface CriteriaTransformerInterface
{
    public function transformEntity(EntityCriteria $entity, string $direction): mixed;
    public function transformWhere(WhereCriteria $where): mixed;
    public function transformOrderBy(OrderByCriteria $orderBy): mixed;
    public function transformBindingType(string $type): mixed;
    public function combineFilters(array $filters, array $orFilters = []): mixed;
}
```

#### QueryResultInterface (src/Contracts/QueryResultInterface.php)
**NEW in v0.6.0** - Modern result objects with convenience methods:
```php
interface QueryResultInterface extends \Countable, \IteratorAggregate
{
    public function getBindings(): array;
    public function isEmpty(): bool;
    public function first(): ?BindingInterface;
    public function count(): int;
}
```

#### Self-Transforming Criteria Objects (src/Query/)
**NEW in v0.6.0** - Each criteria knows how to convert itself:
- `QueryCriteria` - Main query criteria with `transform()` method
- `EntityCriteria` - Entity-specific criteria (from/to entities)
- `WhereCriteria` - Where condition criteria with all operators
- `OrderByCriteria` - Ordering criteria with ASC/DESC directions
- `QueryResult` - Modern result implementation with convenience methods

### Main Classes and Interfaces

#### EdgeBinder (src/EdgeBinder.php)
Main service class implementing EdgeBinderInterface. Provides:
- `bind(object $from, object $to, string $type, array $metadata = []): BindingInterface`
- `unbind(string $bindingId): void`
- `query(): QueryBuilderInterface` ⚡ **Now creates QueryCriteria objects in v0.6.0**
- `findBinding(string $bindingId): ?BindingInterface`

#### PersistenceAdapterInterface (src/Contracts/PersistenceAdapterInterface.php)
Core interface that all adapters must implement:
- `store(BindingInterface $binding): void`
- `find(string $bindingId): ?BindingInterface`
- `delete(string $bindingId): void`
- `executeQuery(QueryCriteria $criteria): QueryResultInterface` ⚡ **v0.6.0 BREAKING CHANGE**
- `count(QueryCriteria $criteria): int` ⚡ **v0.6.0 BREAKING CHANGE**
- `extractEntityId(object $entity): string`
- `extractEntityType(object $entity): string`
- `validateAndNormalizeMetadata(array $metadata): array`

#### Binding (src/Binding.php)
Immutable value object representing a relationship:
- Contains: id, fromType, fromId, toType, toId, type, metadata, timestamps
- Factory method: `Binding::create()` for new instances
- Serialization: `toArray()` and `fromArray()` methods

### Built-in InMemory Adapter

#### InMemoryAdapter (src/Persistence/InMemory/InMemoryAdapter.php)
Production-ready in-memory persistence adapter **updated for v0.6.0**:
- **Full PersistenceAdapterInterface implementation** with new v0.6.0 signatures
- **Uses InMemoryTransformer** - Complete reference implementation of CriteriaTransformerInterface
- **Light adapter pattern** - Just 3 lines per query method using transformer
- **Efficient indexing** - Entity index and type index for fast lookups
- **Advanced query support** - All operators, ordering, pagination, OR conditions
- **Comprehensive metadata validation** - Type checking, nesting limits, DateTime normalization
- **Robust entity extraction** - EntityInterface, methods, properties, fallback strategies
- **Memory management** - Proper cleanup and index maintenance
- **Error handling** - Consistent exception hierarchy with helpful messages

**Use Cases:**
- Unit testing and integration testing
- Development environments and prototyping
- Small applications with minimal persistence needs
- **Reference implementation** for v0.6.0 adapter pattern

#### InMemoryTransformer (src/Persistence/InMemory/InMemoryTransformer.php)
**NEW in v0.6.0** - Complete reference implementation of CriteriaTransformerInterface:
- **All operators supported**: `=`, `>`, `<`, `>=`, `<=`, `!=`, `in`, `notIn`, `between`, `exists`, `null`, `notNull`
- **Complex OR conditions** - Full support for nested OR logic with proper grouping
- **Entity transformation** - Handles from/to entity criteria with type filtering
- **OrderBy transformation** - Field-based ordering with ASC/DESC directions
- **Lazy caching** - Transformation only happens once per transformer instance
- **Perfect example** for implementing your own transformer

#### InMemoryAdapterFactory (src/Persistence/InMemory/InMemoryAdapterFactory.php)
Factory for creating InMemory adapter instances:
- **Implements AdapterFactoryInterface** for consistent extensible adapter pattern
- **Adapter type**: `'inmemory'`
- **No configuration required** - Ignores all config parameters
- **Framework integration** - Works with EdgeBinder::fromConfiguration()

**Usage:**
```php
use EdgeBinder\Registry\AdapterRegistry;
use EdgeBinder\Persistence\InMemory\InMemoryAdapterFactory;

// Register factory
AdapterRegistry::register(new InMemoryAdapterFactory());

// Create EdgeBinder
$edgeBinder = EdgeBinder::fromConfiguration(['adapter' => 'inmemory'], $container);
```

### Framework-Agnostic Extensible Adapter System

#### AdapterFactoryInterface (src/Registry/AdapterFactoryInterface.php)
Interface for third-party adapter factories:
```php
interface AdapterFactoryInterface
{
    public function createAdapter(array $config): PersistenceAdapterInterface;
    public function getAdapterType(): string;
}
```

**Implementation Status**: ✅ COMPLETED
- Full interface with comprehensive PHPDoc
- Detailed configuration examples in docblocks
- Framework integration examples included
- Configuration structure clearly documented

#### AdapterRegistry (src/Registry/AdapterRegistry.php)
Static registry for managing adapter factories:
```php
class AdapterRegistry
{
    public static function register(AdapterFactoryInterface $factory): void; // Idempotent
    public static function create(string $type, array $config): PersistenceAdapterInterface;
    public static function hasAdapter(string $type): bool;
    public static function getRegisteredTypes(): array;
    public static function unregister(string $type): bool; // For testing
    public static function clear(): void; // For testing
    public static function getFactory(string $type): ?AdapterFactoryInterface; // For debugging
}
```

**Implementation Status**: ✅ COMPLETED (Enhanced for Auto-Registration)
- All static methods implemented with proper error handling
- **NEW**: Idempotent registration - duplicate registrations are safely ignored
- **NEW**: Supports auto-registration patterns for adapter packages
- Helpful error messages with available adapter types
- Testing methods for clean test isolation
- Exception wrapping for consistent error handling

#### AdapterException (src/Exception/AdapterException.php)
Exception class for adapter-related errors:
```php
class AdapterException extends EdgeBinderException
{
    public static function factoryNotFound(string $adapterType, array $availableTypes = []): self;
    public static function creationFailed(string $adapterType, string $reason, ?\Throwable $previous = null): self;
    public static function alreadyRegistered(string $adapterType): self;
    public static function invalidConfiguration(string $adapterType, string $reason): self;
    public static function missingConfiguration(string $adapterType, array $missingKeys): self;
}
```

**Implementation Status**: ✅ COMPLETED
- Extends EdgeBinderException following existing patterns
- Factory methods for all common error scenarios
- Helpful error messages with context information
- Proper exception chaining support

### Phase 1 Implementation Status: ✅ COMPLETED

**Core Components Implemented:**
- ✅ AdapterFactoryInterface with comprehensive documentation
- ✅ AdapterRegistry with full static registry functionality
- ✅ AdapterException with factory methods for error scenarios
- ✅ Complete unit test suite with >95% coverage

**Test Coverage:**
- ✅ `tests/Exception/AdapterExceptionTest.php` - Tests all factory methods and error scenarios
- ✅ `tests/Registry/AdapterRegistryTest.php` - Tests registration, creation, and error handling
- ✅ `tests/Registry/AdapterFactoryInterfaceTest.php` - Tests interface contract and implementations

**Key Features Delivered:**
- Framework-agnostic static registry pattern
- Comprehensive error handling with helpful messages
- Clean test isolation with setup/teardown methods
- Proper exception chaining and context preservation
- Configuration validation and normalization support
- Testing utilities for clean test environments

### Phase 2 Implementation Status: ✅ COMPLETED

**EdgeBinder Integration Implemented:**
- ✅ Factory methods added to EdgeBinder class for configuration-based creation
- ✅ Registry-based adapter discovery and creation
- ✅ Backward compatibility maintained with existing constructor
- ✅ Configuration validation with helpful error messages
- ✅ Integration tests with mock third-party adapters

### Phase 3 Implementation Status: ✅ COMPLETED

**Documentation and Examples Implemented:**
- ✅ Complete developer documentation for creating third-party adapters
- ✅ Framework-specific integration examples (Laminas, Symfony, Laravel, Slim)
- ✅ Reference implementation of Redis adapter with comprehensive tests
- ✅ Migration guide for existing custom adapters
- ✅ Updated README.md with extensibility overview and examples
- ✅ API documentation updated with extensible adapter system information

**Phase 3 Deliverables:**
- ✅ `docs/EXTENSIBLE_ADAPTERS.md` - Complete developer guide with step-by-step tutorials
- ✅ `docs/FRAMEWORK_INTEGRATION.md` - Framework-specific integration examples and patterns
- ✅ `docs/MIGRATION_GUIDE.md` - Migration documentation for existing custom adapters
- ✅ `examples/RedisAdapter/` - Complete Redis adapter reference implementation
- ✅ `examples/RedisAdapter/src/RedisAdapter.php` - Full adapter implementation with error handling
- ✅ `examples/RedisAdapter/src/RedisAdapterFactory.php` - Factory implementation with validation
- ✅ `examples/RedisAdapter/tests/` - Comprehensive unit and integration tests
- ✅ Updated `README.md` with extensibility overview, examples, and documentation links

**Key Features Delivered:**
- Complete step-by-step guide for creating third-party adapters
- Framework integration patterns for Laminas, Symfony, Laravel, Slim, and generic PHP
- Reference Redis adapter demonstrating best practices and patterns
- Migration guide for converting existing adapters to the new system
- Comprehensive test examples showing unit and integration testing patterns

### Phase 4 Implementation Status: ✅ COMPLETED

**Auto-Registration Enhancement Implemented:**
- ✅ Idempotent adapter registration - duplicate registrations are safely ignored
- ✅ Version constants added to EdgeBinder class for compatibility checks
- ✅ Enhanced AdapterRegistry with auto-registration support
- ✅ Comprehensive tests for idempotent registration behavior
- ✅ Updated documentation for auto-registration patterns

#### EdgeBinder Version Constant (src/EdgeBinder.php)
```php
class EdgeBinder
{
    public const VERSION = '0.7.1';
}
```

**Auto-Registration Features:**
- **Idempotent Registration**: `AdapterRegistry::register()` can be called multiple times safely
- **Version Compatibility**: Adapters can check EdgeBinder version for compatibility
- **Auto-Registration Ready**: Foundation for adapter packages to self-register
- Updated project documentation with extensibility information

**New EdgeBinder Factory Methods:**
```php
// Create EdgeBinder from configuration using registered adapters
EdgeBinder::fromConfiguration(array $config, ContainerInterface $container, array $globalConfig = []): EdgeBinder

// Create EdgeBinder from adapter (backward compatibility)
EdgeBinder::fromAdapter(PersistenceAdapterInterface $adapter): EdgeBinder
```

**Configuration Format:**
```php
$config = [
    'adapter' => 'weaviate',  // Required: adapter type
    'weaviate_client' => 'weaviate.client.rag',  // Client service name
    'collection_name' => 'RAGBindings',  // Adapter-specific config
    'schema' => ['auto_create' => true],  // More adapter-specific config
];

$edgeBinder = EdgeBinder::fromConfiguration($config, $container, $globalConfig);
```

**Integration Test Coverage:**
- ✅ `tests/Integration/EdgeBinderFactoryTest.php` - Tests factory methods and configuration validation
- ✅ `tests/Integration/AdapterRegistryIntegrationTest.php` - Tests complete workflow from registration to usage
- ✅ `tests/Integration/MockAdapterFactory.php` - Mock adapter factory for testing

**Key Features Delivered:**
- Framework-agnostic EdgeBinder creation from configuration
- Automatic adapter discovery through registry
- Configuration structure transformation for AdapterFactoryInterface
- Comprehensive error handling with context-aware messages
- Full backward compatibility with existing EdgeBinder constructor
- Mock adapters and factories for comprehensive testing

## Using EdgeBinder with Registered Adapters

### Framework Integration Examples

#### Laminas/Mezzio
```php
// In Module.php or application bootstrap
use EdgeBinder\Registry\AdapterRegistry;
use MyVendor\WeaviateAdapter\WeaviateAdapterFactory;

// Register adapter factory
AdapterRegistry::register(new WeaviateAdapterFactory());

// In your service factory
public function __invoke(ContainerInterface $container): EdgeBinder
{
    $config = $container->get('config')['edgebinder']['rag'];
    return EdgeBinder::fromConfiguration($config, $container);
}
```

#### Symfony
```php
// In bundle boot method or compiler pass
use EdgeBinder\Registry\AdapterRegistry;

foreach ($container->findTaggedServiceIds('edgebinder.adapter_factory') as $id => $tags) {
    $factory = $container->get($id);
    AdapterRegistry::register($factory);
}

// In your service
public function createEdgeBinder(ContainerInterface $container): EdgeBinder
{
    $config = $container->getParameter('edgebinder.rag');
    return EdgeBinder::fromConfiguration($config, $container);
}
```

#### Laravel
```php
// In service provider boot method
use EdgeBinder\Registry\AdapterRegistry;

public function boot()
{
    AdapterRegistry::register(new WeaviateAdapterFactory());
}

// In your service
public function createEdgeBinder(): EdgeBinder
{
    $config = config('edgebinder.rag');
    return EdgeBinder::fromConfiguration($config, app());
}
```

#### Generic PHP
```php
// Anywhere in application bootstrap
use EdgeBinder\Registry\AdapterRegistry;
use EdgeBinder\EdgeBinder;
use EdgeBinder\Persistence\InMemory\InMemoryAdapterFactory;

// Register adapters
AdapterRegistry::register(new InMemoryAdapterFactory());
AdapterRegistry::register(new WeaviateAdapterFactory());
AdapterRegistry::register(new JanusAdapterFactory());

// Create EdgeBinder instances
$testConfig = [
    'adapter' => 'inmemory', // For testing/development
];

$ragConfig = [
    'adapter' => 'weaviate',
    'weaviate_client' => 'weaviate.client.rag',
    'collection_name' => 'RAGBindings',
];

$socialConfig = [
    'adapter' => 'janus',
    'janus_client' => 'janus.client.social',
    'graph_name' => 'SocialNetwork',
];

$testBinder = EdgeBinder::fromConfiguration($testConfig, $container);
$ragBinder = EdgeBinder::fromConfiguration($ragConfig, $container);
$socialBinder = EdgeBinder::fromConfiguration($socialConfig, $container);
```

## Creating New Adapters for v0.6.0

### 🚀 v0.6.0 Adapter Development is MUCH Easier!

With the new Criteria Transformer Pattern, creating adapters is dramatically simpler:

### Step 1: Create Your Transformer (NEW in v0.6.0)

First, implement `CriteriaTransformerInterface` for your storage backend:

```php
<?php
namespace MyVendor\MyAdapter;

use EdgeBinder\Contracts\CriteriaTransformerInterface;
use EdgeBinder\Query\{EntityCriteria, WhereCriteria, OrderByCriteria};

class MyCustomTransformer implements CriteriaTransformerInterface
{
    public function transformEntity(EntityCriteria $entity, string $direction): mixed
    {
        // Convert to your storage's entity format
        return [
            'type' => $entity->entityType,
            'id' => $entity->entityId,
            'direction' => $direction
        ];
    }

    public function transformWhere(WhereCriteria $where): mixed
    {
        // Convert to your storage's where format
        return [
            'field' => $where->field,
            'operator' => $this->mapOperator($where->operator),
            'value' => $where->value
        ];
    }

    public function transformOrderBy(OrderByCriteria $orderBy): mixed
    {
        // Convert to your storage's sort format
        return [
            'field' => $orderBy->field,
            'direction' => strtolower($orderBy->direction)
        ];
    }

    public function transformBindingType(string $type): mixed
    {
        return ['bindingType' => $type];
    }

    public function combineFilters(array $filters, array $orFilters = []): mixed
    {
        $combined = ['and' => $filters];
        if (!empty($orFilters)) {
            $combined['or'] = $orFilters;
        }
        return $combined;
    }

    private function mapOperator(string $operator): string
    {
        return match($operator) {
            '=' => 'equals',
            '!=' => 'not_equals',
            '>' => 'greater_than',
            '<' => 'less_than',
            '>=' => 'greater_equal',
            '<=' => 'less_equal',
            'in' => 'in_array',
            'notIn' => 'not_in_array',
            'between' => 'between',
            'exists' => 'exists',
            'null' => 'is_null',
            'notNull' => 'not_null',
            default => throw new \InvalidArgumentException("Unsupported operator: $operator")
        };
    }
}
```

### Step 2: Implement Light Adapter (v0.6.0 Pattern)

Now create your adapter - it's incredibly simple with the transformer pattern:

```php
<?php
namespace MyVendor\MyAdapter;

use EdgeBinder\Contracts\{PersistenceAdapterInterface, QueryResultInterface};
use EdgeBinder\Contracts\BindingInterface;
use EdgeBinder\Query\{QueryCriteria, QueryResult};

class MyCustomAdapter implements PersistenceAdapterInterface
{
    private $client;
    private MyCustomTransformer $transformer;
    private array $config;

    public function __construct($client, array $config = [])
    {
        $this->client = $client;
        $this->transformer = new MyCustomTransformer();
        $this->config = $config;
    }

    // 🚀 v0.6.0 LIGHT ADAPTER PATTERN - Just 3 lines!
    public function executeQuery(QueryCriteria $criteria): QueryResultInterface
    {
        $query = $criteria->transform($this->transformer);  // 1 line transformation!
        $results = $this->executeNativeQuery($query);       // Execute with your client
        return new QueryResult($results);                   // Return QueryResult object
    }

    public function count(QueryCriteria $criteria): int
    {
        $query = $criteria->transform($this->transformer);
        return $this->executeNativeCount($query);
    }

    // Standard methods remain the same
    public function store(BindingInterface $binding): void
    {
        // Implement storage logic using your backend
        // Convert binding to your storage format
        // Handle errors with PersistenceException
    }

    public function find(string $bindingId): ?BindingInterface
    {
        // Implement retrieval logic
        // Return null if not found
        // Convert from storage format to Binding object
    }

    public function delete(string $bindingId): void
    {
        // Implement deletion logic
        // Throw PersistenceException on failure
    }

    public function extractEntityId(object $entity): string
    {
        // Try EntityInterface first, then getId() method, then id property
        // Throw EntityExtractionException if cannot extract
    }

    public function extractEntityType(object $entity): string
    {
        // Try EntityInterface first, then getType() method, then class name
    }

    public function validateAndNormalizeMetadata(array $metadata): array
    {
        // Validate metadata for your storage requirements
        // Throw InvalidMetadataException if invalid
        // Return normalized metadata
    }

    // Your native query methods
    private function executeNativeQuery(array $query): array
    {
        // Execute the transformed query with your client
        // Return array of BindingInterface objects
    }

    private function executeNativeCount(array $query): int
    {
        // Execute count query with your client
        // Return integer count
    }
}
```

### Step 3: Create Adapter Factory

Create a factory implementing `EdgeBinder\Registry\AdapterFactoryInterface`:

```php
<?php
namespace MyVendor\MyAdapter;

use EdgeBinder\Registry\AdapterFactoryInterface;
use EdgeBinder\Contracts\PersistenceAdapterInterface;

class MyCustomAdapterFactory implements AdapterFactoryInterface
{
    public function createAdapter(array $config): PersistenceAdapterInterface
    {
        $container = $config['container'];
        $instanceConfig = $config['instance'];
        $globalConfig = $config['global'];
        
        // Get configuration from flatter structure
        $client = $container->get($instanceConfig['mycustom_client'] ?? 'mycustom.client.default');
        
        // Build adapter configuration from flatter structure
        $adapterConfig = [
            'host' => $instanceConfig['host'] ?? 'localhost',
            'port' => $instanceConfig['port'] ?? 1234,
            // Extract other config directly from instance config
        ];

        return new MyCustomAdapter($client, $adapterConfig);
    }
    
    public function getAdapterType(): string
    {
        return 'mycustom'; // Unique identifier for your adapter
    }
}
```

### Step 4: Register Adapter (Framework Examples)

#### Laminas/Mezzio
```php
// In Module.php or application bootstrap
\EdgeBinder\Registry\AdapterRegistry::register(new MyCustomAdapterFactory());
```

#### Symfony
```php
// In bundle boot method or compiler pass
\EdgeBinder\Registry\AdapterRegistry::register(new MyCustomAdapterFactory());
```

#### Laravel
```php
// In service provider boot method
\EdgeBinder\Registry\AdapterRegistry::register(new MyCustomAdapterFactory());
```

#### Generic PHP
```php
// Anywhere in application bootstrap
\EdgeBinder\Registry\AdapterRegistry::register(new MyCustomAdapterFactory());
```

### Step 5: Configuration

Create configuration that works across all frameworks:

```php
return [
    'edgebinder' => [
        'myinstance' => [
            'adapter' => 'mycustom',
            'mycustom_client' => 'mycustom.client.default',
            'host' => 'localhost',
            'port' => 1234,
            // adapter-specific config directly in instance
        ],
    ],
];
```

## v0.6.0 Migration Guide

### Migrating from v0.5.0 to v0.6.0

#### 🚨 BREAKING CHANGES - Update Required

**1. Update Adapter Interface Signatures:**
```php
// OLD v0.5.0 signatures:
public function executeQuery(QueryBuilderInterface $query): array
public function count(QueryBuilderInterface $query): int  // If implemented

// NEW v0.6.0 signatures:
public function executeQuery(QueryCriteria $criteria): QueryResultInterface
public function count(QueryCriteria $criteria): int
```

**2. Remove Complex Conversion Logic:**
```php
// OLD v0.5.0 - Heavy adapter with manual conversion (50+ lines):
public function executeQuery(QueryBuilderInterface $query): array {
    $criteria = $query->getCriteria();
    $filters = [];
    if ($criteria['from']) {
        // 20+ lines of complex conversion logic...
    }
    if ($criteria['where']) {
        foreach ($criteria['where'] as $condition) {
            // More conversion logic...
        }
    }
    // ... many more lines
    return $this->executeNativeQuery($convertedQuery);
}

// NEW v0.6.0 - Light adapter with transformer (3 lines):
public function executeQuery(QueryCriteria $criteria): QueryResultInterface {
    $query = $criteria->transform($this->transformer);  // 1 line!
    $results = $this->executeNativeQuery($query);
    return new QueryResult($results);
}
```

**3. Create Your Transformer:**
Move all your conversion logic into a dedicated transformer class implementing `CriteriaTransformerInterface`.

**4. Update Tests:**
```php
// OLD v0.5.0 tests:
$results = $adapter->executeQuery($queryBuilder);
$this->assertIsArray($results);
$this->assertCount(2, $results);
$binding = $results[0];

// NEW v0.6.0 tests:
$results = $adapter->executeQuery($criteria);
$this->assertInstanceOf(QueryResultInterface::class, $results);
$this->assertCount(2, $results);
$binding = $results->first(); // or $results->getBindings()[0]
```

### Benefits of v0.6.0 Architecture

1. **Much lighter adapters** - 95% less code in adapter classes
2. **Better separation of concerns** - Adapters execute, transformers convert
3. **Easier testing** - Unit test transformers independently
4. **Better performance** - Lazy caching prevents redundant transformations
5. **Easier maintenance** - Clear, focused responsibilities

## Development Patterns

### Error Handling
- Use specific exceptions from `EdgeBinder\Exception\` namespace
- `PersistenceException` for storage operations
- `EntityExtractionException` for entity ID/type extraction
- `InvalidMetadataException` for metadata validation
- `BindingNotFoundException` for missing bindings
- `AdapterException` for adapter registration and creation errors

### Registry Patterns
- Use `AdapterRegistry::register()` in framework bootstrap/service providers
- Always call `AdapterRegistry::clear()` in test tearDown for clean isolation
- Use `AdapterRegistry::hasAdapter()` before attempting to create adapters
- Wrap adapter creation in try-catch for proper error handling
- Use factory methods on `AdapterException` for consistent error messages

### Entity Extraction Strategy
1. Check if entity implements `EdgeBinder\Contracts\EntityInterface`
2. Try `getId()` and `getType()` methods
3. Fall back to reflection on `id` property and class name
4. Throw `EntityExtractionException` if extraction fails

### Metadata Validation
- Validate data types (no resources, limited objects)
- Check size limits for your storage backend
- Normalize data for optimal storage
- Support `DateTimeInterface` objects

### Testing (Updated for v0.6.0)
- **Test your transformer independently** - Unit test all transformation methods
- **Use AbstractAdapterTestSuite** - Ensures complete v0.6.0 compliance
- **Test QueryResult objects** - Use `first()`, `isEmpty()`, `count()` methods
- Mock external dependencies (clients, connections)
- Test error conditions and edge cases
- Create integration tests with real storage backends

#### v0.6.0 Testing Patterns
```php
// Test transformer independently
class MyTransformerTest extends TestCase
{
    private MyCustomTransformer $transformer;

    public function testTransformWhere(): void
    {
        $where = new WhereCriteria('field', '=', 'value');
        $result = $this->transformer->transformWhere($where);

        $this->assertEquals([
            'field' => 'field',
            'operator' => 'equals',
            'value' => 'value'
        ], $result);
    }
}

// Test adapter with QueryResult
class MyAdapterTest extends AbstractAdapterTestSuite
{
    protected function createAdapter(): PersistenceAdapterInterface
    {
        return new MyCustomAdapter($this->mockClient);
    }

    public function testQueryReturnsQueryResult(): void
    {
        $criteria = new QueryCriteria();
        $result = $this->adapter->executeQuery($criteria);

        $this->assertInstanceOf(QueryResultInterface::class, $result);
        $this->assertTrue($result->isEmpty() || $result->count() > 0);
    }
}
```

## Configuration Patterns

### Standard Configuration Structure (Flatter Approach)
```php
[
    'instance' => [
        'adapter' => 'adapter_type',
        'adapter_type_client' => 'service_name',
        // adapter-specific config directly here
        'host' => 'localhost',
        'port' => 1234,
    ],
    'global' => $globalEdgeBinderConfig, // Full global config for context
    'container' => $psrContainer, // PSR-11 container
]
```

### Multiple Instances (Flatter Configuration)
Support multiple EdgeBinder instances with different adapters:
```php
'edgebinder' => [
    'test' => [
        'adapter' => 'inmemory', // For testing/development
    ],
    'rag' => [
        'adapter' => 'weaviate',
        'weaviate_client' => 'weaviate.client.rag',
        'collection_name' => 'RAGBindings',
        'schema' => ['auto_create' => true, 'vectorizer' => 'text2vec-openai'],
    ],
    'social' => [
        'adapter' => 'janus',
        'janus_client' => 'janus.client.social',
        'graph_name' => 'SocialNetwork',
        'consistency_level' => 'eventual',
    ],
    'cache' => [
        'adapter' => 'redis',
        'redis_client' => 'redis.client.cache',
        'ttl' => 3600,
        'prefix' => 'edgebinder:',
    ],
]
```

## Key Files to Understand

### Core Files
- `src/EdgeBinder.php` - Main service implementation
- `src/Contracts/PersistenceAdapterInterface.php` - Adapter contract
- `src/Binding.php` - Relationship entity
- `src/Registry/AdapterRegistry.php` - Extensibility system

### Built-in Adapter
- `src/Persistence/InMemory/InMemoryAdapter.php` - Built-in reference implementation
- `src/Persistence/InMemory/InMemoryAdapterFactory.php` - Factory for extensible adapter system
- Shows complete PersistenceAdapterInterface implementation with comprehensive test coverage

### Example Third-Party Adapter (Updated for v0.6.0)
- `../weaviate-adapter/src/WeaviateAdapter.php` - Third-party adapter reference **updated for v0.6.0**
- `../weaviate-adapter/src/WeaviateTransformer.php` - **NEW** transformer implementation
- Shows proper v0.6.0 patterns, error handling, configuration, and integration

### Documentation
- `docs/EXTENSIBLE_ADAPTERS.md` - Complete developer guide for creating third-party adapters
- `docs/ADAPTER_TESTING_STANDARD.md` - **REQUIRED** testing compliance guide for all adapters
- `docs/FRAMEWORK_INTEGRATION.md` - Framework-specific integration examples
- `docs/MIGRATION_GUIDE.md` - Migration guide for existing custom adapters
- `docs/FUTURE_PLANS.md` - Future development roadmap and integration patterns
- `docs/ARCHITECTURE_DIAGRAM.md` - System architecture overview
- `README.md` - Getting started and basic usage

## Development Guidelines

### Code Quality
- PHP 8.3+ with strict types
- PHPStan level 8 compliance
- PSR-12 coding standards
- 95%+ test coverage
- Comprehensive PHPDoc

### **REQUIRED: Testing Standard (Updated for v0.6.0)**
**⚠️ CRITICAL**: All adapters MUST extend `AbstractAdapterTestSuite` for v0.6.0 compliance testing.

```php
// Location: src/Testing/AbstractAdapterTestSuite.php
abstract class AbstractAdapterTestSuite extends TestCase
{
    protected PersistenceAdapterInterface $adapter;
    protected EdgeBinder $edgeBinder;

    abstract protected function createAdapter(): PersistenceAdapterInterface;
    abstract protected function cleanupAdapter(): void;

    // Provides 57+ comprehensive integration tests UPDATED FOR v0.6.0:
    // - All public API methods tested with QueryCriteria and QueryResult objects
    // - Complex query scenarios (from, to, type, where, ordering, pagination)
    // - OR condition support and complex nested queries
    // - QueryResult interface compliance (isEmpty(), first(), count(), getBindings())
    // - Metadata validation and normalization edge cases
    // - Entity extraction with all fallback scenarios
    // - Error handling for all failure modes
    // - Data consistency and indexing validation
    // - Proven to catch production bugs (found 5+ critical issues)
}
```

**Usage Example (v0.6.0):**
```php
class MyAdapterTest extends AbstractAdapterTestSuite
{
    protected function createAdapter(): PersistenceAdapterInterface
    {
        return new MyAdapter($this->setupClient());
    }

    protected function cleanupAdapter(): void
    {
        $this->teardownClient();
    }

    // 57+ tests inherited automatically - ensures 100% v0.6.0 compliance
    // Tests automatically verify QueryResult objects and new interface signatures
}
```

### Naming Conventions
- Adapter classes: `{Name}Adapter` (e.g., `InMemoryAdapter`, `WeaviateAdapter`)
- Factory classes: `{Name}AdapterFactory` (e.g., `InMemoryAdapterFactory`, `WeaviateAdapterFactory`)
- Adapter types: lowercase (e.g., 'inmemory', 'weaviate', 'janus', 'redis')
- Service names: `{adapter}.client.{connection}` (e.g., 'weaviate.client.rag')

## Common Implementation Patterns (Updated for v0.6.0)

### v0.6.0 Adapter Constructor Pattern
```php
public function __construct($client, array $config = [])
{
    $this->client = $client;
    $this->transformer = new MyCustomTransformer();  // NEW: Include transformer
    $this->config = array_merge($this->getDefaultConfig(), $config);
}
```

### v0.6.0 Query Execution Pattern
```php
public function executeQuery(QueryCriteria $criteria): QueryResultInterface
{
    try {
        $query = $criteria->transform($this->transformer);  // Transform once
        $results = $this->executeNativeQuery($query);       // Execute with client
        return new QueryResult($results);                   // Return QueryResult
    } catch (\Exception $e) {
        throw PersistenceException::queryFailed($e->getMessage(), $e);
    }
}
```

### Configuration Validation Pattern
```php
private function validateConfiguration(array $config): void
{
    $required = ['client', 'collection_name'];
    foreach ($required as $key) {
        if (!isset($config[$key])) {
            throw new \InvalidArgumentException("Required config key '{$key}' missing");
        }
    }
}
```

### Error Handling Pattern
```php
try {
    $result = $this->client->operation($data);
    if (!$result) {
        throw PersistenceException::operationFailed('store', 'Client returned false');
    }
} catch (\Exception $e) {
    if ($e instanceof PersistenceException) {
        throw $e;
    }
    throw PersistenceException::serverError('store', $e->getMessage(), $e);
}
```

### Entity Extraction Pattern
```php
public function extractEntityId(object $entity): string
{
    if ($entity instanceof EntityInterface) {
        return $entity->getId();
    }

    if (method_exists($entity, 'getId')) {
        $id = $entity->getId();
        if (is_string($id) && !empty($id)) {
            return $id;
        }
    }

    if (property_exists($entity, 'id')) {
        $id = $entity->id;
        if (is_string($id) && !empty($id)) {
            return $id;
        }
    }

    throw new EntityExtractionException('Cannot extract entity ID', $entity);
}
```

## Testing Patterns

### Mock Adapter Factory for Testing
```php
class MockAdapterFactory implements AdapterFactoryInterface
{
    private PersistenceAdapterInterface $adapter;

    public function __construct(PersistenceAdapterInterface $adapter)
    {
        $this->adapter = $adapter;
    }

    public function createAdapter(array $config): PersistenceAdapterInterface
    {
        return $this->adapter;
    }

    public function getAdapterType(): string
    {
        return 'mock';
    }
}
```

### Integration Test Pattern
```php
public function testAdapterRegistrationAndUsage(): void
{
    // Register adapter
    AdapterRegistry::register(new MyCustomAdapterFactory());

    // Verify registration
    $this->assertTrue(AdapterRegistry::hasAdapter('mycustom'));

    // Create adapter through registry
    $config = [
        'instance' => [
            'adapter' => 'mycustom',
            'mycustom_client' => 'test.client',
            'host' => 'localhost',
            'port' => 1234,
        ],
        'global' => $globalConfig,
        'container' => $this->container,
    ];

    $adapter = AdapterRegistry::create('mycustom', $config);
    $this->assertInstanceOf(PersistenceAdapterInterface::class, $adapter);
}
```

## Framework Integration Patterns

### Laminas ConfigProvider Pattern
```php
class ConfigProvider
{
    public function __invoke(): array
    {
        return [
            'dependencies' => [
                'factories' => [
                    MyCustomAdapterFactory::class => function() {
                        return new MyCustomAdapterFactory();
                    },
                ],
            ],
        ];
    }
}

// In Module.php
public function onBootstrap($e)
{
    $container = $e->getApplication()->getServiceManager();
    $factory = $container->get(MyCustomAdapterFactory::class);
    AdapterRegistry::register($factory);
}
```

### Symfony Service Configuration Pattern
```yaml
# services.yaml
services:
    MyVendor\MyAdapter\MyCustomAdapterFactory:
        tags: ['edgebinder.adapter_factory']
```

```php
// Compiler pass
foreach ($container->findTaggedServiceIds('edgebinder.adapter_factory') as $id => $tags) {
    $factory = $container->get($id);
    AdapterRegistry::register($factory);
}
```

### Laravel Service Provider Pattern
```php
class MyAdapterServiceProvider extends ServiceProvider
{
    public function boot()
    {
        AdapterRegistry::register(new MyCustomAdapterFactory());
    }

    public function register()
    {
        $this->app->singleton('edgebinder.adapter.mycustom', function() {
            return new MyCustomAdapterFactory();
        });
    }
}
```

## Troubleshooting Guide

### Common Issues

1. **Adapter Not Found**: Ensure `AdapterRegistry::register()` is called before EdgeBinder instantiation
2. **Configuration Errors**: Verify config structure matches expected format
3. **Container Service Missing**: Ensure client services are registered in container
4. **Entity Extraction Fails**: Implement EntityInterface or ensure getId()/getType() methods exist
5. **Metadata Validation**: Check size limits and data types for your storage backend

### Debug Helpers
```php
// Check registered adapters
$types = AdapterRegistry::getRegisteredTypes();
var_dump($types);

// Validate configuration structure
$required = ['instance', 'global', 'container'];
foreach ($required as $key) {
    if (!isset($config[$key])) {
        throw new \InvalidArgumentException("Missing config key: {$key}");
    }
}
```

## v0.6.0 Key Takeaways

### For Adapter Developers
1. **Implement CriteriaTransformerInterface first** - This is where your conversion logic goes
2. **Keep adapters light** - Just call `$criteria->transform($transformer)` and execute
3. **Return QueryResult objects** - Use `new QueryResult($results)`
4. **Test transformers independently** - Unit test all transformation methods
5. **Use AbstractAdapterTestSuite** - Ensures complete v0.6.0 compliance

### Architecture Benefits
- **95% less adapter code** - Transformers handle all conversion logic
- **Better separation of concerns** - Clear responsibilities between adapters and transformers
- **Easier testing** - Test transformation logic independently from execution
- **Better performance** - Lazy caching prevents redundant transformations
- **Easier maintenance** - Focused, single-responsibility classes

### Migration Checklist
- [ ] Update interface signatures to use `QueryCriteria` and `QueryResultInterface`
- [ ] Create transformer implementing `CriteriaTransformerInterface`
- [ ] Move conversion logic from adapter to transformer
- [ ] Update adapter to use transformer pattern (3 lines per method)
- [ ] Update tests to work with `QueryResult` objects
- [ ] Extend `AbstractAdapterTestSuite` for compliance testing

This comprehensive context provides complete guidance for creating and migrating adapters to EdgeBinder v0.6.0's revolutionary architecture that works seamlessly across all PHP frameworks.
